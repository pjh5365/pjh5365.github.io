---
title: 99클럽 코테 스터디 14일차 TIL
author: pjh5365
date: 2024-11-10 18:51:00 +0900
categories: [Study, Algorithm]
tags: [java, 알고리즘, 99클럽, 코딩테스트준비, 개발자취업, 항해99, TIL]
image:
  path: /assets/img/tilJava.png
  alt: 항해99 TIL Logo

---

## 문제

[프로그래머스 - 미로 탈출 명령어](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

### 해결 방법

1. 맨해튼 거리 공식으로 미로 탈출 조건에 부합하지 못한다면 바로 `impossible` 을 반환하고 종료한다.
1. 빠른 문자열 순인 `d`, `l`, `r`, `u` 순으로 탐색하도록 `dx`, `dy` 를 구성하고 DFS 탐색을 진행한다.
1. 시간 초과를 막기 위해 탐색을 진행하면서 맨해튼 거리를 계산해 탈출 조건을 검사한다.

### 정답 코드 - JAVA

```java
import java.util.*;

class Solution {
    static int N;
    static int M;
    static int R;
    static int C;
    static int K;
    static int[] dx = {1, 0, 0, -1};
    static int[] dy = {0, -1, 1, 0};
    static char[] ds = {'d', 'l', 'r', 'u'};
    static StringBuilder sb = new StringBuilder();
    static String ret;
    
    public String solution(int n, int m, int x, int y, int r, int c, int k) {
        N = n;
        M = m;
        R = r;
        C = c;
        K = k;
        
        int len = distance(x, y, r, c);
        if ((k - len) % 2 == 1 || k < len) {
            return "impossible";
        }
        dfs(x, y, 0);
        if (ret == null) {
            ret = "impossible";
        }
        return ret;
    }
    
    static int distance(int x, int y, int r, int c){
        return (int)Math.abs(x-r) + (int)Math.abs(y-c);
    }

    
    static void dfs(int x, int y, int k) {
        if (ret != null) {
            return;
        }
        if(k + distance(x, y, R, C) > K) {
            return;
        }

        if (k == K) {
            ret = sb.toString();
            return;
        }
        
        for (int i = 0; i < 4; i++) {
            int X = dx[i] + x;
            int Y = dy[i] + y;
            
            if (X < 1 || X > N || Y < 1 || Y > M) {
                continue;
            }
            
            sb.append(ds[i]);
            dfs(X, Y, k + 1);
            sb.delete(k, k + 1);
        }
    }
}
```

## 오늘의 회고

일반적인 DFS로 `k` 만큼 탐색하여 탈출할 수 있는 경우 리스트에 추가하고, 마지막에 정렬하는 방식으로 시도했지만, 시간 초과로 실패했다. 시간 초과를 방지하기 위해 항상  `d`, `l`, `r`, `u`  순으로 탐색하면, 탈출 지점에 도착했을 때 가장 빠른 문자열이 된다는 점을 활용해 문제를 해결할 수 있었다.
