---
title: 99클럽 코테 스터디 11일차 TIL (그리디)
author: pjh5365
date: 2024-11-07 19:27:00 +0900
categories: [Study, Algorithm]
tags: [java, 알고리즘, 99클럽, 코딩테스트준비, 개발자취업, 항해99, TIL]
image:
  path: /assets/img/tilJava.png
  alt: 항해99 TIL Logo

---

## 문제

[BOJ 1461 - 도서관](https://www.acmicpc.net/problem/1461)

### 해결 방법

1. 책들의 원래 위치를 `-` 와 `+` 에 따라 각자 다른 우선순위 큐에 입력한다.
    - 이때 우선순위 큐는 내림차순으로 설정한다.
1. 책을 최대로 들고 `이동하는 거리 * 2` 를 결괏값이 저장한 후 마지막 책을 놓은 뒤에는 다시 돌아올 필요가 없으므로 나온 결괏값에 가장 먼 거리를 빼준다.

### 정답 코드 - JAVA

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int ret = 0;
        int max = 0;

        PriorityQueue<Integer> plus = new PriorityQueue<>(Collections.reverseOrder());
        PriorityQueue<Integer> minus = new PriorityQueue<>(Collections.reverseOrder());

        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            int tmp = Integer.parseInt(st.nextToken());
            max = Math.max(max, Math.abs(tmp));

            if (tmp < 0) {
                minus.add(-tmp);
            } else {
                plus.add(tmp);
            }
        }

        while (!minus.isEmpty()) {
            int tmp = minus.poll();
            for (int i = 0; i < M - 1; i++) {
                minus.poll();

                if (minus.isEmpty()) {
                    break;
                }
            }
            ret += tmp * 2;
        }

        while (!plus.isEmpty()) {
            int tmp = plus.poll();
            for (int i = 0; i < M - 1; i++) {
                plus.poll();

                if (plus.isEmpty()) {
                    break;
                }
            }
            ret += tmp * 2;
        }

        ret -= max;

        bw.write(String.valueOf(ret));
        bw.flush();
    }
}
```

## 오늘의 회고

우선순위 큐를 사용하면 별도로 정렬을 해줄 필요가 없어 손쉽게 풀이를 진행할 수 있었다.

