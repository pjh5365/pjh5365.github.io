---
title: 99클럽 코테 스터디 29일차 TIL
author: pjh5365
date: 2024-11-25 18:55:00 +0900
categories: [Study, Algorithm]
tags: [java, 알고리즘, 99클럽, 코딩테스트준비, 개발자취업, 항해99, TIL]
image:
  path: /assets/img/tilJava.png
  alt: 항해99 TIL Logo

---

## 문제

[BOJ 11657 - 타임머신 ](https://www.acmicpc.net/problem/11657)

### 해결 방법

1. 벨만 포드 알고리즘을 사용해 음의 사이클이 존재하는지 구한다.

### 정답 코드 - JAVA

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N;
    static int M;
    static int[][] graph;
    static long[] dist;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();
        StringTokenizer st = new StringTokenizer(br.readLine());

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        graph = new int[N + 1][N + 1];
        dist = new long[N + 1];

        for (int i = 1; i <= N; i++) {
            Arrays.fill(graph[i], Integer.MAX_VALUE);
        }
        Arrays.fill(dist, (int)1e9);
        dist[1] = 0;

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            graph[a][b] = Math.min(graph[a][b], c);
        }

        if (bellmanFord()) {
            sb.append("-1").append("\n");
        } else {
            for (int i = 2; i <= N; i++) {
                if (dist[i] == 1e9) {
                    sb.append("-1").append("\n");
                } else {
                    sb.append(dist[i]).append("\n");
                }
            }
        }

        bw.write(String.valueOf(sb));
        bw.newLine();
        bw.flush();
    }

    static boolean bellmanFord() {
        for (int i = 1; i < N; i++) { // 1번 노드 빼고 탐색
            for (int v = 1; v <= N; v++) { // 경유지노드
                for (int u = 1; u <= N; u++) { // 도착지 노드
                    if (dist[v] == 1e9) {
                        continue;
                    }
                    if (dist[u] > dist[v] + graph[v][u]) {
                        dist[u] = dist[v] + graph[v][u];
                    }
                }
            }
        }
        for (int v = 1; v <= N; v++) { // 경유지노드
            for (int u = 1; u <= N; u++) { // 도착지 노드
                if (dist[v] == 1e9) {
                    break;
                }
                if (dist[u] > dist[v] + graph[v][u]) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

## 오늘의 회고

벨만 포드 알고리즘을 적용하면 해결할 수 있는 문제이다.
