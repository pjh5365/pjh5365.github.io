---
title: 99클럽 코테 스터디 8일차 TIL (다익스트라)
author: pjh5365
date: 2024-11-04 18:15:00 +0900
categories: [Study, Algorithm]
tags: [java, 알고리즘, 99클럽, 코딩테스트준비, 개발자취업, 항해99, TIL]
image:
  path: /assets/img/tilJava.png
  alt: 항해99 TIL Logo

---

## 다익스트라 알고리즘

### 개념

음의 가중치가 없을 때 단일 출발지에서 모든 노드까지의 최단 경로를 구하는 알고리즘이다.

### 작동 원리

- 시작 노드를 0으로 설정하고, 다른 노드들의 최단 거리를 무한대로 설정한다.
- 방문하지 않은 노드 중 가장 거리가 짧은 노드를 선택하고, 해당 노드를 통해 다른 노드로 가는 경로를 탐색하여 경로를 갱신한다.
    - 우선순위 큐를 사용해 최단 거리를 가진 노드를 찾을 수 있다.

## 문제

[BOJ 4485 - 녹색 옷 입은 애가 젤다지?](https://www.acmicpc.net/problem/4485)

### 해결 방법

1. `Pair` 클래스를 우선순위 큐에 넣을 수 있도록 `Comparable` 를 구현해준다.
1. 그래프를 입력받는다.
1. BFS 탐색을 할 때 최솟값부터 탐색할 수 있도록 우선순위 큐를 사용해 탐색을 진행한다. (다익스트라 알고리즘)

### 정답 코드 - JAVA

```java
import java.io.*;
import java.util.*;

public class Main {
    static int N;
    static int[][] arr;
    static int[][] sum;
    static int[] dx = {0, 0, 1, -1};
    static int[] dy = {1, -1, 0, 0};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();

        int problem = 1;
        int result = 0;
        while (true) {
            N = Integer.parseInt(br.readLine());

            if (N == 0) {
                break;
            }

            arr = new int[N][N];
            sum = new int[N][N];
            for (int i = 0; i < N; i++) {
                StringTokenizer st = new StringTokenizer(br.readLine());
                for (int j = 0; j < N; j++) {
                    arr[i][j] = Integer.parseInt(st.nextToken());
                    sum[i][j] = Integer.MAX_VALUE;
                }
            }

            result = bfs();
            sb.append("Problem ").append(problem).append(": ").append(result).append("\n");
            problem++;
        }

        bw.write(String.valueOf(sb));
        bw.flush();
    }

    static int bfs() {
        Queue<Pair> q = new PriorityQueue<>();

        q.add(new Pair(0, 0, arr[0][0]));
        boolean[][] visited = new boolean[N][N];

        while (!q.isEmpty()) {
            Pair now = q.poll();

            for (int i = 0; i < 4; i++) {
                int x = now.x + dx[i];
                int y = now.y + dy[i];

                if (x < 0 || x > N - 1 || y < 0 || y > N - 1) {
                    continue;
                }

                int tmp = now.sum + arr[x][y];

                if (!visited[x][y] && sum[x][y] > tmp) {    // 최소값이 바뀐다면
                    visited[x][y] = true;
                    sum[x][y] = tmp;
                    q.add(new Pair(x, y, tmp));
                }
            }
        }
        return sum[N - 1][N - 1];
    }

    static class Pair implements Comparable<Pair> {
        int x;
        int y;
        int sum;

        public Pair(int x, int y, int sum) {
            this.x = x;
            this.y = y;
            this.sum = sum;
        }

        @Override
        public int compareTo(Pair o) {
            return this.sum - o.sum;
        }
    }
}
```

## 오늘의 회고

BFS와 우선순위 큐를 활용해 다익스트라를 구현하여 풀 수 있었던 문제였다.
